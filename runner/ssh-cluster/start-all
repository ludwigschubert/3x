#!/usr/bin/env bash
# ssh-cluster/start-all -- start running all runs on a cluster via ssh
# 
# > . find-runner.sh -
# > start-all _3X_WORKER_DIR
#
# Author: Jaeho Shin <netj@cs.stanford.edu>
# Created: 2014-02-24
set -eu

_3X_WORKER_DIR=$1; shift

. ssh-cluster-runner.sh

cd "$_3X_WORKER_DIR"

envSpecPath=$(findOneInTargetOrRunners environ)
remotes=(
$(useTargetOrRunnerConfig remotes +2 "remote hosts:" | no-comments)
)

# TODO filter out unresponsive remotes first
numRemotes=${#remotes[@]}

# set up a repository clone at remote shared-path
remote=${remotes[$(($RANDOM % $numRemotes))]} # randomly picking one
parseRemote $remote; remoteRoot=$sharedPath
sharedRemote=$(getParsedRemoteURL)
_3X_LOGLVL=$((_3X_LOGLVL + 1)) \
setup-remote-repo $sharedRemote "$_3X_WORKER_ID"
rsyncToRemote "$_3X_WORKER_ID"/.3x/environ "$envSpecPath"

# split runIds and runArgs for each remote
[[ $numRemotes -gt 0 ]] || runner-error "No remote hosts are available"
paste run{Serial,Id,Arg}s |
split --number=r/$numRemotes - runSplit.

# start runs at each remote
splits=($(ls runSplit.*))
scheduleRuns() {
    local remote=$1 i=$2
    local split=${splits[i]}
    local numScheduled=$(wc -l <$split)
    [[ $numScheduled -gt 0 ]] || return 0
    parseRemote $remote
    runner-msg "scheduling $numScheduled runs at $remote"
    # record which remote host is running which runs
    echo $remote >$split.remote
    echo $remote >>remotes
    touch "$_3X_QUEUE_DIR"/$ACTIVE_FLAG
    ssh-3x-remote $remote start <$split
}
eachInParallel scheduleRuns "${remotes[@]}"
waitAll
